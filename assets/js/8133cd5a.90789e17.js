"use strict";(self.webpackChunka_bit_of_program=self.webpackChunka_bit_of_program||[]).push([[2607],{3724:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var i=a(4848),t=a(8453);const r={},s="You don't know JS",o={id:"javascript/you-dont-know-js",title:"You don't know JS",description:"github book link",source:"@site/docs/javascript/you-dont-know-js.md",sourceDirName:"javascript",slug:"/javascript/you-dont-know-js",permalink:"/a-bit-of-program/docs/javascript/you-dont-know-js",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/javascript/you-dont-know-js.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u6837\u5f0f\u914d\u7f6e",permalink:"/a-bit-of-program/docs/docusaurus/tutorial-extras/custom-style"},next:{title:"kafka",permalink:"/a-bit-of-program/docs/kafka/"}},l={},c=[{value:"Chapter 4",id:"chapter-4",level:2},{value:"Around the Global Scope",id:"around-the-global-scope",level:3},{value:"Globals Shadowing Globals",id:"globals-shadowing-globals",level:4},{value:"DOM Globals",id:"dom-globals",level:4},{value:"What&#39;s in a (Window) Name?",id:"whats-in-a-window-name",level:4},{value:"Web Workers",id:"web-workers",level:4},{value:"Node",id:"node",level:4},{value:"Others",id:"others",level:4},{value:"Chapter 5: The (Not So) Secret Lifecycle of Variables",id:"chapter-5-the-not-so-secret-lifecycle-of-variables",level:2},{value:"Hoisting: Declaration vs. Expression",id:"hoisting-declaration-vs-expression",level:3},{value:"Re-declaration?",id:"re-declaration",level:3},{value:"Loop",id:"loop",level:3},{value:"TDZ",id:"tdz",level:3},{value:"Chapter 6: Limiting Scope Exposure",id:"chapter-6-limiting-scope-exposure",level:2},{value:"Hiding in Plain (Function) Scope",id:"hiding-in-plain-function-scope",level:3},{value:"var and let",id:"var-and-let",level:3},{value:"Chapter 7: Using Closures",id:"chapter-7-using-closures",level:2},{value:"closure is variable-oriented",id:"closure-is-variable-oriented",level:3},{value:"Per Variable or Per Scope?",id:"per-variable-or-per-scope",level:3},{value:"An Alternative Perspective",id:"an-alternative-perspective",level:3},{value:"Why Closure?",id:"why-closure",level:3},{value:"Summary",id:"summary",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"you-dont-know-js",children:"You don't know JS"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://github.com/getify/You-Dont-Know-JS/",children:"github book link"})})}),"\n",(0,i.jsx)(n.h2,{id:"chapter-4",children:"Chapter 4"}),"\n",(0,i.jsx)(n.h3,{id:"around-the-global-scope",children:"Around the Global Scope"}),"\n",(0,i.jsx)(n.h4,{id:"globals-shadowing-globals",children:"Globals Shadowing Globals"}),"\n",(0,i.jsx)(n.p,{children:"The difference between following two code snippets."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"window.something=12\nlet something=13\n\nwindow.something=12\nvar something=13\n"})}),"\n",(0,i.jsx)(n.h4,{id:"dom-globals",children:"DOM Globals"}),"\n",(0,i.jsx)(n.p,{children:"One surprising behavior in the global scope you may encounter with browser-based JS applications: a DOM element with an id attribute automatically creates a global variable that references it."}),"\n",(0,i.jsx)(n.p,{children:"Consider this markup:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-md",children:'<ul id="my-todo-list">\n   <li id="first">Write a book</li>\n   ..\n</ul>\n'})}),"\n",(0,i.jsx)(n.p,{children:"And the JS for that page could include:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-md",children:'first;\n// <li id="first">..</li>\n\nwindow["my-todo-list"];\n// <ul id="my-todo-list">..</ul>\n'})}),"\n",(0,i.jsx)(n.h4,{id:"whats-in-a-window-name",children:"What's in a (Window) Name?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-md",children:'var name = 42;\n\nconsole.log(name, typeof name);\n// "42" string\n'})}),"\n",(0,i.jsx)(n.p,{children:'But the truly surprising behavior is that even though we assigned the number 42 to name (and thus window.name), when we then retrieve its value, it\'s a string "42"! In this case, the weirdness is because name is actually a pre-defined getter/setter on the window object, which insists on its value being a string value. Yikes!'}),"\n",(0,i.jsx)(n.h4,{id:"web-workers",children:"Web Workers"}),"\n",(0,i.jsx)(n.p,{children:"Web Workers are a web platform extension on top of browser-JS behavior, which allows a JS file to run in a completely separate thread (operating system wise) from the thread that's running the main JS program."}),"\n",(0,i.jsx)(n.p,{children:"Since these Web Worker programs run on a separate thread, they're restricted in their communications with the main application thread, to avoid/limit race conditions and other complications. Web Worker code does not have access to the DOM, for example. Some web APIs are, however, made available to the worker, such as navigator."}),"\n",(0,i.jsx)(n.p,{children:"In a Web Worker, the global object reference is typically made using self:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var studentName = "Kyle";\nlet studentID = 42;\n\nfunction hello() {\n    console.log(`Hello, ${ self.studentName }!`);\n}\n\nself.hello();\n// Hello, Kyle!\n\nself.studentID;\n// undefined\n'})}),"\n",(0,i.jsx)(n.h4,{id:"node",children:"Node"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'global.studentName = "Kyle";\n\nfunction hello() {\n    console.log(`Hello, ${ studentName }!`);\n}\n\nhello();\n// Hello, Kyle!\n\nmodule.exports.hello = hello;\n'})}),"\n",(0,i.jsx)(n.h4,{id:"others",children:"Others"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const theGlobalScopeObject =\n    (new Function("return this"))();\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const theGlobalScopeObject =\n    (typeof globalThis != "undefined") ? globalThis :\n    (typeof global != "undefined") ? global :\n    (typeof window != "undefined") ? window :\n    (typeof self != "undefined") ? self :\n    (new Function("return this"))();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"chapter-5-the-not-so-secret-lifecycle-of-variables",children:"Chapter 5: The (Not So) Secret Lifecycle of Variables"}),"\n",(0,i.jsx)(n.h3,{id:"hoisting-declaration-vs-expression",children:"Hoisting: Declaration vs. Expression"}),"\n",(0,i.jsx)(n.p,{children:"A function declaration is hoisted and initialized to its function value (again, called function hoisting). A var variable is also hoisted, and then auto-initialized to undefined. Any subsequent function expression assignments to that variable don't happen until that assignment is processed during runtime execution."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'greeting();\n// TypeError\n\nvar greeting = function greeting() {\n    console.log("Hello!");\n};\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'greeting = "Hello!";\nconsole.log(greeting);\n// Hello!\n\nvar greeting = "Howdy!";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"re-declaration",children:"Re-declaration?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var studentName = "Frank";\nconsole.log(studentName);\n// Frank\n\nvar studentName;\nconsole.log(studentName);   // ???\n'})}),"\n",(0,i.jsx)(n.p,{children:"hoisting is actually about registering a variable at the beginning of a scope"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var studentName = "Frank";\nconsole.log(studentName);   // Frank\n\nvar studentName;\nconsole.log(studentName);   // Frank <--- still!\n\n// let\'s add the initialization explicitly\nvar studentName = undefined;\nconsole.log(studentName);   // undefined <--- see!?\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var greeting;\n\nfunction greeting() {\n    console.log("Hello!");\n}\n\n// basically, a no-op\nvar greeting;\n\ntypeof greeting;        // "function"\n\nvar greeting = "Hello!";\n\ntypeof greeting;        // "string"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'let studentName = "Frank";\n\nvar studentName = "Suzy"; // SyntaxError\n'})}),"\n",(0,i.jsx)(n.h3,{id:"loop",children:"Loop"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var keepGoing = true;\nwhile (keepGoing) {\n    let value = Math.random();\n    if (value > 0.5) {\n        keepGoing = false;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:'All the rules of scope (including "re-declaration" of let-created variables) are applied per scope instance. In other words, each time a scope is entered during execution, everything resets.'}),"\n",(0,i.jsx)(n.p,{children:"Each loop iteration is its own new scope instance, and within each scope instance, value is only being declared once."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"for (let i = 0; i < 3; i++) {\n    let value = i * 10;\n    console.log(`${ i }: ${ value }`);\n}\n// 0: 0\n// 1: 10\n// 2: 20\n"})}),"\n",(0,i.jsx)(n.p,{children:"equivalent form"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"{\n    // a fictional variable for illustration\n    let $$i = 0;\n\n    for ( /* nothing */; $$i < 3; $$i++) {\n        // here's our actual loop `i`!\n        let i = $$i;\n\n        let value = i * 10;\n        console.log(`${ i }: ${ value }`);\n    }\n    // 0: 0\n    // 1: 10\n    // 2: 20\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"tdz",children:"TDZ"}),"\n",(0,i.jsx)(n.p,{children:"The TDZ is the time window where a variable exists but is still uninitialized, and therefore cannot be accessed in any way. Only the execution of the instructions left by Compiler at the point of the original declaration can do that initialization. After that moment, the TDZ is done, and the variable is free to be used for the rest of the scope."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'studentName = "Suzy";   // let\'s try to initialize it!\n// ReferenceError\n\nconsole.log(studentName);\n\nlet studentName;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var studentName = "Kyle";\n\n{\n    console.log(studentName);\n    // ???\n\n    // ..\n\n    let studentName = "Suzy";\n\n    console.log(studentName);\n    // Suzy\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"chapter-6-limiting-scope-exposure",children:"Chapter 6: Limiting Scope Exposure"}),"\n",(0,i.jsx)(n.h3,{id:"hiding-in-plain-function-scope",children:"Hiding in Plain (Function) Scope"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var factorial = (function hideTheCache() {\n    var cache = {};\n\n    function factorial(x) {\n        if (x < 2) return 1;\n        if (!(x in cache)) {\n            cache[x] = x * factorial(x - 1);\n        }\n        return cache[x];\n    }\n\n    return factorial;\n})();\n\nfactorial(6);\n// 720\n\nfactorial(7);\n// 5040\n"})}),"\n",(0,i.jsx)(n.p,{children:"So, in other words, we're defining a function expression that's then immediately invoked. This common pattern has a (very creative!) name: Immediately Invoked Function Expression (IIFE)."}),"\n",(0,i.jsx)(n.h3,{id:"var-and-let",children:"var and let"}),"\n",(0,i.jsx)(n.p,{children:"var attaches to the nearest enclosing function scope, no matter where it appears. That's true even if var appears inside a block:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"function diff(x,y) {\n    if (x > y) {\n        var tmp = x;    // `tmp` is function-scoped\n        x = y;\n        y = tmp;\n    }\n\n    return y - x;\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"chapter-7-using-closures",children:"Chapter 7: Using Closures"}),"\n",(0,i.jsx)(n.h3,{id:"closure-is-variable-oriented",children:"closure is variable-oriented"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var studentName = "Frank";\n\nvar greeting = function hello() {\n    // we are closing over `studentName`,\n    // not "Frank"\n    console.log(\n        `Hello, ${ studentName }!`\n    );\n}\n\n// later\n\nstudentName = "Suzy";\n\n// later\n\ngreeting();\n// Hello, Suzy!\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var keeps = [];\n\nfor (var i = 0; i < 3; i++) {\n    keeps[i] = function keepI(){\n        // closure over `i`\n        return i;\n    };\n}\n\nkeeps[0]();   // 3 -- WHY!?\nkeeps[1]();   // 3\nkeeps[2]();   // 3\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var keeps = [];\n\nfor (var i = 0; i < 3; i++) {\n    // new `j` created each iteration, which gets\n    // a copy of the value of `i` at this moment\n    let j = i;\n\n    // the `i` here isn't being closed over, so\n    // it's fine to immediately use its current\n    // value in each loop iteration\n    keeps[i] = function keepEachJ(){\n        // close over `j`, not `i`!\n        return j;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var keeps = [];\n\nfor (let i = 0; i < 3; i++) {\n    // the `let i` gives us a new `i` for\n    // each iteration, automatically!\n    keeps[i] = function keepEachI(){\n        return i;\n    };\n}\nkeeps[0]();   // 0\nkeeps[1]();   // 1\nkeeps[2]();   // 2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"per-variable-or-per-scope",children:"Per Variable or Per Scope?"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"debug closure",src:a(1516).A+"",width:"2048",height:"1732"})}),"\n",(0,i.jsx)(n.h3,{id:"an-alternative-perspective",children:"An Alternative Perspective"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// outer/global scope: RED(1)\n\nfunction adder(num1) {\n    // function scope: BLUE(2)\n\n    return function addTo(num2){\n        // function scope: GREEN(3)\n\n        return num1 + num2;\n    };\n}\n\nvar add10To = adder(10);\nvar add42To = adder(42);\n\nadd10To(15);    // 25\nadd42To(9);     // 51\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Visualizing Closures",src:a(630).A+"",width:"1662",height:"1380"})}),"\n",(0,i.jsx)(n.h3,{id:"why-closure",children:"Why Closure?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var APIendpoints = {\n    studentIDs:\n        "https://some.api/register-students",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction makeRequest(evt) {\n    var btn = evt.target;\n    var recordKind = btn.dataset.kind;\n    ajax(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n}\n\n// <button data-kind="studentIDs">\n//    Register Students\n// </button>\nbtn.addEventListener("click",makeRequest);\n'})}),"\n",(0,i.jsx)(n.p,{children:"it's unfortunate (inefficient, more confusing) that the event handler has to read a DOM attribute each time it's fired."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'var APIendpoints = {\n    studentIDs:\n        "https://some.api/register-students",\n    // ..\n};\n\nvar data = {\n    studentIDs: [ 14, 73, 112, 6 ],\n    // ..\n};\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n\n    btn.addEventListener(\n        "click",\n        function makeRequest(evt){\n            ajax(\n                APIendpoints[recordKind],\n                data[recordKind]\n            );\n        }\n    );\n}\n\n// <button data-kind="studentIDs">\n//    Register Students\n// </button>\n\nsetupButtonHandler(btn);\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'function setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var requestURL = APIendpoints[recordKind];\n    var requestData = data[recordKind];\n\n    btn.addEventListener(\n        "click",\n        function makeRequest(evt){\n            ajax(requestURL,requestData);\n        }\n    );\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Two similar techniques from the Functional Programming (FP) paradigm that rely on closure are partial application and currying. Briefly, with these techniques, we alter the shape of functions that require multiple inputs so some inputs are provided up front, and other inputs are provided later; the initial inputs are remembered via closure. Once all inputs have been provided, the underlying action is performed."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'function defineHandler(requestURL,requestData) {\n    return function makeRequest(evt){\n        ajax(requestURL,requestData);\n    };\n}\n\nfunction setupButtonHandler(btn) {\n    var recordKind = btn.dataset.kind;\n    var handler = defineHandler(\n        APIendpoints[recordKind],\n        data[recordKind]\n    );\n    btn.addEventListener("click",handler);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"We explored two models for mentally tackling closure:"}),"\n",(0,i.jsx)(n.p,{children:"Observational: closure is a function instance remembering its outer variables even as that function is passed to and invoked in other scopes."}),"\n",(0,i.jsx)(n.p,{children:"Implementational: closure is a function instance and its scope environment preserved in-place while any references to it are passed around and invoked from other scopes."}),"\n",(0,i.jsx)(n.p,{children:"Benefits to our programs:"}),"\n",(0,i.jsx)(n.p,{children:"Closure can improve efficiency by allowing a function instance to remember previously determined information instead of having to compute it each time."}),"\n",(0,i.jsx)(n.p,{children:"Closure can improve code readability, bounding scope-exposure by encapsulating variable(s) inside function instances, while still making sure the information in those variables is accessible for future use. The resultant narrower, more specialized function instances are cleaner to interact with, since the preserved information doesn't need to be passed in every invocation."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},630:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/Visualizing Closures-ca2157e6a26a9a8769fe6de61b42ceab.png"},1516:(e,n,a)=>{a.d(n,{A:()=>i});const i=a.p+"assets/images/debug-closure-692436864dbab70272f2322011f454b2.png"},8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var i=a(6540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);